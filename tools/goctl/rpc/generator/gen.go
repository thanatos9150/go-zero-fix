package generator

import (
	"path/filepath"

	"github.com/thanatos9150/go-zero-fix/tools/goctl/rpc/parser"
	"github.com/thanatos9150/go-zero-fix/tools/goctl/util/console"
	"github.com/thanatos9150/go-zero-fix/tools/goctl/util/ctx"
	"github.com/thanatos9150/go-zero-fix/tools/goctl/util/pathx"
)

type ZRpcContext struct {
	// Src is the source file of the proto.
	Src string
	// ProtocCmd is the command to generate proto files.
	ProtocCmd string
	// ProtoGenGrpcDir is the directory to store the generated proto files.
	ProtoGenGrpcDir string
	// ProtoGenGoDir is the directory to store the generated go files.
	ProtoGenGoDir string
	// IsGooglePlugin is the flag to indicate whether the proto file is generated by google plugin.
	IsGooglePlugin bool
	// GoOutput is the output directory of the generated go files.
	GoOutput string
	// GrpcOutput is the output directory of the generated grpc files.
	GrpcOutput string
	// Output is the output directory of the generated files.
	Output string
	// ClientOutput is the output directory of the generated rpc client files.
	ClientOutput string
	// Multiple is the flag to indicate whether the proto file is generated in multiple mode.
	Multiple bool
	// Whether to generate rpc client
	IsGenClient bool
	// Module is the custom module name for go.mod
	Module string
}

// Generate generates a rpc service, through the proto file,
// code storage directory, and proto import parameters to control
// the source file and target location of the rpc service that needs to be generated
func (g *Generator) Generate(zctx *ZRpcContext) error {
	abs, err := filepath.Abs(zctx.Output)
	if err != nil {
		return err
	}

	err = pathx.MkdirIfNotExist(abs)
	if err != nil {
		return err
	}

	absClient, err := filepath.Abs(zctx.ClientOutput)
	if err != nil {
		return err
	}

	err = pathx.MkdirIfNotExist(absClient)
	if err != nil {
		return err
	}

	err = g.Prepare()
	if err != nil {
		return err
	}

	var projectCtx *ctx.ProjectContext
	if len(zctx.Module) > 0 {
		projectCtx, err = ctx.PrepareWithModule(abs, zctx.Module)
	} else {
		projectCtx, err = ctx.Prepare(abs)
	}
	if err != nil {
		return err
	}
	projectCtx.ClientDir = absClient

	p := parser.NewDefaultProtoParser()
	proto, err := p.Parse(zctx.Src, zctx.Multiple)
	if err != nil {
		return err
	}

	dirCtx, err := mkdir(projectCtx, proto, g.cfg, zctx)
	if err != nil {
		return err
	}

	err = g.GenEtc(dirCtx, proto, g.cfg)
	if err != nil {
		return err
	}

	err = g.GenPb(dirCtx, zctx)
	if err != nil {
		return err
	}

	err = g.GenConfig(dirCtx, proto, g.cfg)
	if err != nil {
		return err
	}

	err = g.GenSvc(dirCtx, proto, g.cfg)
	if err != nil {
		return err
	}

	err = g.GenLogic(dirCtx, proto, g.cfg, zctx)
	if err != nil {
		return err
	}

	err = g.GenServer(dirCtx, proto, g.cfg, zctx)
	if err != nil {
		return err
	}

	err = g.GenMain(dirCtx, proto, g.cfg, zctx)
	if err != nil {
		return err
	}

	if zctx.IsGenClient {
		err = g.GenCall(dirCtx, proto, g.cfg, zctx)
	}

	console.NewColorConsole().MarkDone()

	return err
}
